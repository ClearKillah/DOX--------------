import logging
import json
import os
import sys
import time
import asyncio
import datetime
import random
from typing import Dict, Any, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes, ConversationHandler
from dotenv import load_dotenv
import telegram

import database as db

# Enable logging with more detailed level
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO,  # Changed to INFO for production
    stream=sys.stdout  # Output to stdout for immediate visibility
)
logger = logging.getLogger(__name__)

# Conversation states
START, CHATTING, PROFILE, EDIT_PROFILE = range(4)

# User data file
USER_DATA_FILE = "user_data.json"

# Load user data from file
def load_user_data():
    if os.path.exists(USER_DATA_FILE):
        with open(USER_DATA_FILE, "r", encoding="utf-8") as file:
            return json.load(file)
    return {}

# Save user data to file
def save_user_data(data):
    with open(USER_DATA_FILE, "w", encoding="utf-8") as file:
        json.dump(data, file, ensure_ascii=False, indent=4)

# User data structure
user_data = load_user_data()
active_chats = {}  # Store active chat pairs
searching_users = {}  # Store users who are currently searching
chat_stats = {}  # Store chat statistics and message counts

# Constants for achievements
ACHIEVEMENTS = {
    "CHAT_MASTER": {"name": "üí¨ –ú–∞—Å—Ç–µ—Ä –æ–±—â–µ–Ω–∏—è", "description": "–ü—Ä–æ–≤–µ–¥–µ–Ω–æ 50 —á–∞—Ç–æ–≤", "requirement": 50},
    "POPULAR": {"name": "‚≠ê –ü–æ–ø—É–ª—è—Ä–Ω—ã–π —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫", "description": "–ü–æ–ª—É—á–µ–Ω–æ 20 –æ—Ü–µ–Ω–æ–∫ 5 –∑–≤–µ–∑–¥", "requirement": 20},
    "ACTIVE": {"name": "üî• –ê–∫—Ç–∏–≤–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", "description": "3 –¥–Ω—è –ø–æ–¥—Ä—è–¥ –≤ —á–∞—Ç–µ", "requirement": 3},
}

class ChatStats:
    def __init__(self):
        self.start_time = time.time()
        self.message_count = 0
        self.is_typing = False
        self.last_message_time = time.time()

# Load environment variables
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN")

# Constants for buttons
FIND_PARTNER = "üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞"
END_CHAT = "üö´ –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç"
MY_PROFILE = "üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å"
HELP = "‚ùì –ü–æ–º–æ—â—å"

# Constants for callback data
CALLBACK_RATE = "rate_"
CALLBACK_GENDER = "gender_"
CALLBACK_AGE = "age_"
CALLBACK_INTEREST = "interest_"

# Interests
INTERESTS = [
    "–ú—É–∑—ã–∫–∞", "–ö–∏–Ω–æ", "–°–ø–æ—Ä—Ç", "–ò–≥—Ä—ã", "–ö–Ω–∏–≥–∏", 
    "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è", "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏", "–ò—Å–∫—É—Å—Å—Ç–≤–æ", "–ù–∞—É–∫–∞", "–ö—É–ª–∏–Ω–∞—Ä–∏—è"
]

async def update_search_timer(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Update the search timer message."""
    job = context.job
    user_id, message_id, start_time = job.data
    
    # Calculate elapsed time
    elapsed_seconds = int(time.time() - start_time)
    minutes = elapsed_seconds // 60
    seconds = elapsed_seconds % 60
    
    # Update message with new timer
    try:
        await context.bot.edit_message_text(
            chat_id=user_id,
            message_id=message_id,
            text=f"üîç *–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...*\n\n‚è± –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: {minutes:02d}:{seconds:02d}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="cancel_search")]
            ])
        )
    except Exception as e:
        logger.error(f"Error updating search timer: {e}")
        context.job_queue.remove_job(job.name)

async def send_typing_notification(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send typing notification to simulate real conversation."""
    job = context.job
    chat_id = job.data
    
    try:
        await context.bot.send_chat_action(
            chat_id=chat_id,
            action="typing"
        )
    except Exception as e:
        logger.error(f"Error sending typing notification: {e}")
        context.job_queue.remove_job(job.name)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Send welcome message when the command /start is issued."""
    try:
        logger.debug("Start command received from user %s", update.effective_user.id)
        user_id = str(update.effective_user.id)
        
        # Initialize user if not exists
        if user_id not in user_data:
            user_data[user_id] = {
                "gender": None,
                "age": None,
                "interests": [],
                "chat_count": 0,
                "rating": 0,
                "rating_count": 0
            }
            save_user_data(user_data)
            logger.debug("New user initialized: %s", user_id)
        
        keyboard = [
            [
                InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile"),
                InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")
            ],
            [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Get user stats
        chat_count = user_data[user_id].get("chat_count", 0)
        rating = user_data[user_id].get("rating", 0)
        rating_stars = "‚≠ê" * int(rating) + "‚òÜ" * (5 - int(rating))
        
        # Create welcome message
        welcome_text = (
            f"üëã –ü—Ä–∏–≤–µ—Ç, {update.effective_user.first_name}!\n\n"
            f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Dox: –ê–Ω–æ–Ω–∏–º–Ω—ã–π –ß–∞—Ç!\n\n"
            f"–ó–¥–µ—Å—å —Ç—ã –º–æ–∂–µ—à—å –∞–Ω–æ–Ω–∏–º–Ω–æ –æ–±—â–∞—Ç—å—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏. "
            f"–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏."
        )
        
        # Add user stats if they have any chats
        if chat_count > 0:
            welcome_text += (
                f"üìä –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Ç–æ–≤: {chat_count}\n"
            )
            if rating > 0:
                welcome_text += f"üìà –†–µ–π—Ç–∏–Ω–≥: {rating_stars} ({rating:.1f}/5)\n"
            welcome_text += "\n"
        
        welcome_text += "*–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:*"
        
        logger.debug("Sending welcome message to user %s", user_id)
        await update.message.reply_text(
            welcome_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        logger.debug("Welcome message sent successfully")
        
        return START
    except Exception as e:
        logger.error("Error in start command: %s", str(e), exc_info=True)
        # Try to send a simple message without formatting or buttons if there was an error
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
            )
        except Exception:
            logger.error("Failed to send error message", exc_info=True)
        return START

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle button presses."""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    
    if query.data == "profile":
        return await show_profile(update, context)
    
    elif query.data == "find_chat":
        return await find_chat(update, context)
    
    elif query.data == "cancel_search":
        # Remove user from searching list
        if user_id in searching_users:
            del searching_users[user_id]
        
        keyboard = [
            [
                InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile"),
                InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")
            ]
        ]
        
        await query.edit_message_text(
            text="‚ùå *–ü–æ–∏—Å–∫ –æ—Ç–º–µ–Ω–µ–Ω*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return START
    
    elif query.data == "skip_user":
        # Skip current chat partner and find a new one
        if user_id in active_chats:
            partner_id = active_chats[user_id]
            
            # Notify partner that chat has ended
            if partner_id in active_chats:
                try:
                    await context.bot.send_message(
                        chat_id=int(partner_id),
                        text="‚ùå *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                            [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
                        ])
                    )
                    del active_chats[partner_id]
                except Exception as e:
                    logger.error(f"Error notifying partner: {e}")
            
            del active_chats[user_id]
        
        # Start new search
        search_message = await query.edit_message_text(
            text="üîç *–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...*\n\n‚è± –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: 00:00",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="cancel_search")]
            ])
        )
        
        # Add user to searching users
        searching_users[user_id] = {
            "start_time": time.time(),
            "message_id": search_message.message_id,
            "chat_id": query.message.chat_id
        }
        
        # Start continuous search in background
        asyncio.create_task(continuous_search(user_id, context))
        
        return START
    
    elif query.data == "end_chat":
        return await end_chat(update, context)
    
    elif query.data.startswith("rate_"):
        # Handle rating
        parts = query.data.split("_")
        if len(parts) == 3:
            partner_id = parts[1]
            rating = int(parts[2])
            
            # Save rating
            if partner_id in user_data:
                ratings = user_data[partner_id].get("ratings", [])
                ratings.append(rating)
                user_data[partner_id]["ratings"] = ratings
                user_data[partner_id]["avg_rating"] = sum(ratings) / len(ratings)
                save_user_data(user_data)
            
            await query.edit_message_text(
                text=f"‚úÖ *–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ü–µ–Ω–∫—É!*\n\n–í—ã –ø–æ—Å—Ç–∞–≤–∏–ª–∏ {rating} {'‚≠ê' * rating}",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                    [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
                ])
            )
        else:
            await query.edit_message_text(
                text="‚ùå *–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ü–µ–Ω–∫–µ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞*",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                    [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
                ])
            )
        return START
    
    elif query.data == "skip_rating":
        await query.edit_message_text(
            text="‚úÖ *–û—Ü–µ–Ω–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞*",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
            ])
        )
        return START
    
    elif query.data == "back_to_start":
        keyboard = [
            [
                InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile"),
                InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")
            ]
        ]
        
        await query.edit_message_text(
            text="*–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Dox: –ê–Ω–æ–Ω–∏–º–Ω—ã–π –ß–∞—Ç* üé≠\n\n"
                 "–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –∞–Ω–æ–Ω–∏–º–Ω–æ –æ–±—â–∞—Ç—å—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏.\n\n"
                 "*–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:*",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return START
    
    # Handle interest selection
    elif query.data.startswith("interest_"):
        interest = query.data.split("_")[1]
        
        if user_id in user_data:
            interests = user_data[user_id].get("interests", [])
            
            if interest in interests:
                interests.remove(interest)
            else:
                interests.append(interest)
            
            user_data[user_id]["interests"] = interests
            save_user_data(user_data)
        
        # Show updated profile
        return await show_profile(update, context)
    
    # Handle edit profile
    elif query.data == "edit_profile":
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –≤–æ–∑—Ä–∞—Å—Ç", callback_data="edit_age")],
            [InlineKeyboardButton("üñº –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞–≤–∞—Ç–∞—Ä", callback_data="upload_avatar")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data="profile")]
        ]
        
        await query.edit_message_text(
            text="*–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è*\n\n–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return EDIT_PROFILE
    
    elif query.data == "edit_age":
        await query.edit_message_text(
            text="*–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–∑—Ä–∞—Å—Ç:*\n\n"
                 "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ –æ—Ç 13 –¥–æ 100.",
            parse_mode="Markdown"
        )
        context.user_data["edit_field"] = "age"
        return EDIT_PROFILE
    
    elif query.data == "upload_avatar":
        await query.edit_message_text(
            text="*–ó–∞–≥—Ä—É–∑–∫–∞ –∞–≤–∞—Ç–∞—Ä–∞*\n\n"
                 "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ –∞–≤–∞—Ç–∞—Ä.\n\n"
                 "–î–ª—è –æ—Ç–º–µ–Ω—ã –Ω–∞–∂–º–∏—Ç–µ /cancel",
            parse_mode="Markdown"
        )
        context.user_data["uploading_avatar"] = True
        return PROFILE
    
    return START

async def show_profile(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show user profile."""
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    user_info = user_data.get(user_id, {})
    gender = "üë® –ú—É–∂—Å–∫–æ–π" if user_info.get("gender") == "male" else "üë© –ñ–µ–Ω—Å–∫–∏–π" if user_info.get("gender") == "female" else "‚ùì –ù–µ —É–∫–∞–∑–∞–Ω"
    age = user_info.get("age", "‚ùì –ù–µ —É–∫–∞–∑–∞–Ω")
    
    # Get chat statistics
    chat_count = user_info.get("chat_count", 0)
    total_messages = user_info.get("total_messages", 0)
    avg_chat_duration = user_info.get("avg_chat_duration", 0)
    achievements = user_info.get("achievements", [])
    
    # Calculate average chat duration in minutes
    avg_duration_min = int(avg_chat_duration / 60) if avg_chat_duration else 0
    
    # Format interests
    interests = user_info.get("interests", [])
    interests_text = ""
    if "flirt" in interests:
        interests_text += "‚Ä¢ üíò –§–ª–∏—Ä—Ç\n"
    if "chat" in interests:
        interests_text += "‚Ä¢ üí¨ –û–±—â–µ–Ω–∏–µ\n"
    if not interests_text:
        interests_text = "‚ùì –ù–µ —É–∫–∞–∑–∞–Ω—ã"
    
    # Calculate rating and trend
    rating = user_info.get("rating", 0)
    rating_count = user_info.get("rating_count", 0)
    prev_rating = user_info.get("prev_rating", 0)
    rating_trend = "üìà" if rating > prev_rating else "üìâ" if rating < prev_rating else "‚û°Ô∏è"
    rating_stars = "‚≠ê" * int(rating) + "‚òÜ" * (5 - int(rating))
    
    # Format achievements
    achievements_text = ""
    if achievements:
        for achievement_id in achievements:
            achievement = ACHIEVEMENTS.get(achievement_id)
            if achievement:
                achievements_text += f"‚Ä¢ {achievement['name']}\n"
    else:
        achievements_text = "–ü–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"
    
    # Create profile completion percentage
    completed_fields = 0
    total_fields = 3
    if user_info.get("gender"): completed_fields += 1
    if user_info.get("age"): completed_fields += 1
    if interests: completed_fields += 1
    completion_percentage = int(completed_fields / total_fields * 100)
    completion_bar = "‚ñì" * (completion_percentage // 10) + "‚ñë" * (10 - completion_percentage // 10)
    
    # Build profile text
    profile_text = (
        f"üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:*\n\n"
        f"*–ó–∞–ø–æ–ª–Ω–µ–Ω–æ:* {completion_percentage}% {completion_bar}\n\n"
        f"*–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*\n"
        f"‚Ä¢ –ü–æ–ª: {gender}\n"
        f"‚Ä¢ –í–æ–∑—Ä–∞—Å—Ç: {age}\n"
        f"*–ò–Ω—Ç–µ—Ä–µ—Å—ã:*\n{interests_text}\n\n"
        f"*üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\n"
        f"‚Ä¢ –í—Å–µ–≥–æ —á–∞—Ç–æ–≤: {chat_count}\n"
        f"‚Ä¢ –°–æ–æ–±—â–µ–Ω–∏–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {total_messages}\n"
        f"‚Ä¢ –°—Ä–µ–¥–Ω—è—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–∞—Ç–∞: {avg_duration_min} –º–∏–Ω.\n"
        f"‚Ä¢ –†–µ–π—Ç–∏–Ω–≥: {rating_stars} {rating_trend} ({rating:.1f}/5)\n"
        f"  –ù–∞ –æ—Å–Ω–æ–≤–µ {rating_count} –æ—Ü–µ–Ω–æ–∫\n\n"
        f"*üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è:*\n{achievements_text}"
    )
    
    # Create keyboard
    keyboard = [
        [InlineKeyboardButton("üì∏ –ó–∞–≥—Ä—É–∑–∏—Ç—å –∞–≤–∞—Ç–∞—Ä", callback_data="upload_avatar")],
        [InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å", callback_data="edit_profile")],
        [InlineKeyboardButton("üîÑ –ò–∑–º–µ–Ω–∏—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å—ã", callback_data="interest_edit")],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_to_start")]
    ]
    
    # Send avatar if exists
    avatar_path = f"avatars/{user_id}.jpg"
    if os.path.exists(avatar_path):
        try:
            with open(avatar_path, "rb") as photo:
                await context.bot.send_photo(
                    chat_id=query.message.chat_id,
                    photo=photo,
                    caption=profile_text,
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="Markdown"
                )
            return PROFILE
        except Exception as e:
            logger.error(f"Error sending avatar: {e}")
    
    # Send profile without avatar
    await query.edit_message_text(
        text=profile_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    
    return PROFILE

async def handle_avatar_upload(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle avatar photo upload."""
    user_id = str(update.effective_user.id)
    
    if update.message and update.message.photo:
        photo_file = await update.message.photo[-1].get_file()
        avatar_path = await save_avatar(user_id, photo_file)
        
        if avatar_path:
            await update.message.reply_text(
                "‚úÖ –ê–≤–∞—Ç–∞—Ä —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!\n\n–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø—Ä–æ—Ñ–∏–ª—é...",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üë§ –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å", callback_data="profile")
                ]])
            )
        else:
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∞–≤–∞—Ç–∞—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
    else:
        await update.message.reply_text(
            "üì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ –∞–≤–∞—Ç–∞—Ä.\n"
            "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
        )
    
    return PROFILE

async def find_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start looking for a chat partner."""
    user_id = str(update.effective_user.id)
    logger.debug(f"User {user_id} is looking for a chat partner")
    
    # End current chat if any
    if user_id in active_chats:
        partner_id = active_chats[user_id]
        
        # Notify partner that chat has ended
        if partner_id in active_chats:
            try:
                await context.bot.send_message(
                    chat_id=int(partner_id),
                    text="‚ùå *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                        [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
                    ])
                )
                del active_chats[partner_id]
            except Exception as e:
                logger.error(f"Error notifying partner: {e}")
        
        del active_chats[user_id]
    
    # Send initial search message
    if update.callback_query:
        search_message = await update.callback_query.edit_message_text(
            text="üîç *–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...*\n\n‚è± –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: 00:00",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="cancel_search")]
            ])
        )
    else:
        search_message = await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="üîç *–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...*\n\n‚è± –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: 00:00",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="cancel_search")]
            ])
        )
    
    # Add user to searching users
    searching_users[user_id] = {
        "start_time": time.time(),
        "message_id": search_message.message_id,
        "chat_id": update.effective_chat.id
    }
    
    # Start continuous search in background
    asyncio.create_task(continuous_search(user_id, context))
    
    return START

async def continuous_search(user_id: str, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Continuously search for a chat partner in the background."""
    try:
        if user_id not in searching_users:
            return
        
        search_info = searching_users[user_id]
        start_time = search_info["start_time"]
        chat_id = search_info["chat_id"]
        message_id = search_info["message_id"]
        
        # Keep searching until a partner is found or search is cancelled
        while user_id in searching_users:
            # Update search time
            current_time = time.time()
            search_time = current_time - start_time
            minutes = int(search_time) // 60
            seconds = int(search_time) % 60
            time_text = f"‚è± –í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞: {minutes:02d}:{seconds:02d}"
            
            # Update search message every 5 seconds
            if seconds % 5 == 0:
                try:
                    await context.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=message_id,
                        text=f"üîç *–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞...*\n\n{time_text}",
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫", callback_data="cancel_search")]
                        ])
                    )
                except Exception as e:
                    logger.error(f"Error updating search message: {e}")
            
            # Find available users - ONLY those who are also searching
            available_users = []
            for uid, search_data in searching_users.items():
                # Skip the current user and users already in chat
                if uid != user_id and uid not in active_chats:
                    available_users.append(uid)
            
            if available_users:
                # Found a partner!
                partner_id = random.choice(available_users)
                logger.debug(f"Matched user {user_id} with partner {partner_id}")
                
                # Get partner's search info before removing from searching
                partner_search_info = searching_users.get(partner_id, {})
                partner_chat_id = partner_search_info.get("chat_id")
                partner_message_id = partner_search_info.get("message_id")
                
                # Remove both users from searching
                if user_id in searching_users:
                    del searching_users[user_id]
                if partner_id in searching_users:
                    del searching_users[partner_id]
                
                # Create chat connection
                active_chats[user_id] = partner_id
                active_chats[partner_id] = user_id
                
                # Initialize chat stats
                chat_stats[user_id] = ChatStats()
                chat_stats[partner_id] = ChatStats()
                
                # Increment chat count for both users
                if user_id in user_data:
                    user_data[user_id]["chat_count"] = user_data[user_id].get("chat_count", 0) + 1
                if partner_id in user_data:
                    user_data[partner_id]["chat_count"] = user_data[partner_id].get("chat_count", 0) + 1
                save_user_data(user_data)
                
                # Get partner info
                partner_info = user_data.get(partner_id, {})
                gender = "üë® –ú—É–∂—Å–∫–æ–π" if partner_info.get("gender") == "male" else "üë© –ñ–µ–Ω—Å–∫–∏–π" if partner_info.get("gender") == "female" else "–ù–µ —É–∫–∞–∑–∞–Ω"
                age = partner_info.get("age", "–ù–µ —É–∫–∞–∑–∞–Ω")
                
                # Prepare partner info message
                partner_text = f"*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–µ:*\n\n"
                if partner_info.get("gender"):
                    partner_text += f"*–ü–æ–ª:* {gender}\n"
                if partner_info.get("age"):
                    partner_text += f"*–í–æ–∑—Ä–∞—Å—Ç:* {age}\n"
                
                interests = partner_info.get("interests", [])
                if interests:
                    interests_text = ""
                    if "flirt" in interests:
                        interests_text += "‚Ä¢ üíò –§–ª–∏—Ä—Ç\n"
                    if "chat" in interests:
                        interests_text += "‚Ä¢ üí¨ –û–±—â–µ–Ω–∏–µ\n"
                    partner_text += f"*–ò–Ω—Ç–µ—Ä–µ—Å—ã:*\n{interests_text}"
                
                # Notify both users
                keyboard = [
                    [InlineKeyboardButton("‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_user")],
                    [InlineKeyboardButton("‚ùå –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç", callback_data="end_chat")]
                ]
                
                try:
                    # Send message to the user who initiated the search
                    await context.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=message_id,
                        text=f"‚úÖ *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω!*\n\n{partner_text}\n\n*–ù–∞—á–Ω–∏—Ç–µ –æ–±—â–µ–Ω–∏–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!*",
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                    
                    # Pin the message
                    try:
                        pinned_message = await context.bot.pin_chat_message(
                            chat_id=chat_id,
                            message_id=message_id,
                            disable_notification=True
                        )
                    except Exception as e:
                        logger.error(f"Error pinning message for user {user_id}: {e}")
                    
                    # Get user info for partner
                    user_info = user_data.get(user_id, {})
                    user_text = f"*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–µ:*\n\n"
                    if user_info.get("gender"):
                        user_gender = "üë® –ú—É–∂—Å–∫–æ–π" if user_info.get("gender") == "male" else "üë© –ñ–µ–Ω—Å–∫–∏–π"
                        user_text += f"*–ü–æ–ª:* {user_gender}\n"
                    if user_info.get("age"):
                        user_text += f"*–í–æ–∑—Ä–∞—Å—Ç:* {user_info.get('age')}\n"
                    
                    user_interests = user_info.get("interests", [])
                    if user_interests:
                        interests_text = ""
                        if "flirt" in user_interests:
                            interests_text += "‚Ä¢ üíò –§–ª–∏—Ä—Ç\n"
                        if "chat" in user_interests:
                            interests_text += "‚Ä¢ üí¨ –û–±—â–µ–Ω–∏–µ\n"
                        user_text += f"*–ò–Ω—Ç–µ—Ä–µ—Å—ã:*\n{interests_text}"
                    
                    # If partner was also searching, edit their search message
                    if partner_chat_id and partner_message_id:
                        try:
                            await context.bot.edit_message_text(
                                chat_id=partner_chat_id,
                                message_id=partner_message_id,
                                text=f"‚úÖ *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω!*\n\n{user_text}\n\n*–ù–∞—á–Ω–∏—Ç–µ –æ–±—â–µ–Ω–∏–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!*",
                                parse_mode="Markdown",
                                reply_markup=InlineKeyboardMarkup(keyboard)
                            )
                            
                            # Pin message for partner
                            try:
                                await context.bot.pin_chat_message(
                                    chat_id=partner_chat_id,
                                    message_id=partner_message_id,
                                    disable_notification=True
                                )
                            except Exception as e:
                                logger.error(f"Error pinning message for partner {partner_id}: {e}")
                                
                        except Exception as e:
                            logger.error(f"Error updating partner's search message: {e}")
                    else:
                        # Partner wasn't searching, send a new message
                        try:
                            partner_message = await context.bot.send_message(
                                chat_id=int(partner_id),
                                text=f"‚úÖ *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω!*\n\n{user_text}\n\n*–ù–∞—á–Ω–∏—Ç–µ –æ–±—â–µ–Ω–∏–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!*",
                                parse_mode="Markdown",
                                reply_markup=InlineKeyboardMarkup(keyboard)
                            )
                            
                            # Pin message for partner
                            try:
                                await context.bot.pin_chat_message(
                                    chat_id=int(partner_id),
                                    message_id=partner_message.message_id,
                                    disable_notification=True
                                )
                            except Exception as e:
                                logger.error(f"Error pinning message for partner {partner_id}: {e}")
                                
                        except Exception as e:
                            logger.error(f"Error sending message to partner {partner_id}: {e}")
                            # If we can't send a message to the partner, clean up the chat
                            if user_id in active_chats:
                                del active_chats[user_id]
                            if partner_id in active_chats:
                                del active_chats[partner_id]
                            
                            # Notify the user that the partner is unavailable
                            try:
                                await context.bot.edit_message_text(
                                    chat_id=chat_id,
                                    message_id=message_id,
                                    text="‚ùå *–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≤—è–∑–∞—Ç—å—Å—è —Å —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–º*\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–π—Ç–∏ –¥—Ä—É–≥–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞.",
                                    parse_mode="Markdown",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                                        [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
                                    ])
                                )
                            except Exception as e:
                                logger.error(f"Error notifying user about partner unavailability: {e}")
                            
                            # Continue searching
                            continue
                    
                except Exception as e:
                    logger.error(f"Error notifying users about match: {e}")
                    # Clean up if notification fails
                    if user_id in active_chats:
                        del active_chats[user_id]
                    if partner_id in active_chats:
                        del active_chats[partner_id]
                    continue
                
                break
            
            # Wait before checking again
            await asyncio.sleep(1)
            
    except Exception as e:
        logger.error(f"Error in continuous_search: {e}", exc_info=True)
        # Clean up if there was an error
        if user_id in searching_users:
            del searching_users[user_id]

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle messages during chat."""
    user_id = str(update.effective_user.id)
    
    # Check if editing profile
    if context.user_data.get("edit_field") == "age":
        try:
            age = int(update.message.text)
            if 13 <= age <= 100:  # Basic age validation
                user_data[user_id]["age"] = age
                save_user_data(user_data)
                
                keyboard = [
                    [InlineKeyboardButton("–§–ª–∏—Ä—Ç", callback_data="interest_flirt")],
                    [InlineKeyboardButton("–û–±—â–µ–Ω–∏–µ", callback_data="interest_chat")],
                    [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data="profile")]
                ]
                
                await update.message.reply_text(
                    text="‚úÖ *–í–æ–∑—Ä–∞—Å—Ç —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!*\n\n*–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à–∏ –∏–Ω—Ç–µ—Ä–µ—Å—ã:*",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="Markdown"
                )
                del context.user_data["edit_field"]
                return EDIT_PROFILE
            else:
                await update.message.reply_text(
                    "‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç (–æ—Ç 13 –¥–æ 100)."
                )
                return EDIT_PROFILE
        except ValueError:
            await update.message.reply_text(
                "‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç –≤ –≤–∏–¥–µ —á–∏—Å–ª–∞."
            )
            return EDIT_PROFILE
    
    # Check if uploading avatar
    if context.user_data.get("uploading_avatar"):
        if update.message.photo:
            return await handle_avatar_upload(update, context)
        elif update.message.text == "/cancel":
            del context.user_data["uploading_avatar"]
            await update.message.reply_text(
                "‚ùå –ó–∞–≥—Ä—É–∑–∫–∞ –∞–≤–∞—Ç–∞—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üë§ –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data="profile")
                ]])
            )
            return PROFILE
        else:
            await update.message.reply_text(
                "üì∏ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return PROFILE
    
    # Check if in active chat
    if user_id in active_chats:
        partner_id = active_chats[user_id]
        
        try:
            # Initialize chat stats if not exists
            if user_id not in chat_stats:
                chat_stats[user_id] = ChatStats()
            
            # Update message count
            chat_stats[user_id].message_count += 1
            user_data[user_id]["total_messages"] = user_data[user_id].get("total_messages", 0) + 1
            
            # Check if message is a command
            if update.message.text and update.message.text.startswith('/'):
                if update.message.text.lower() == '/end':
                    return await end_chat(update, context)
                elif update.message.text.lower() == '/help':
                    await update.message.reply_text(
                        "*–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*\n"
                        "/end - –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç–µ–∫—É—â–∏–π —á–∞—Ç\n"
                        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
                        "/stats - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —á–∞—Ç–∞",
                        parse_mode="Markdown"
                    )
                    return CHATTING
                elif update.message.text.lower() == '/stats':
                    stats = chat_stats.get(user_id)
                    if stats:
                        duration = int((time.time() - stats.start_time) / 60)
                        await update.message.reply_text(
                            f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —á–∞—Ç–∞:*\n\n"
                            f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration} –º–∏–Ω.\n"
                            f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {stats.message_count}",
                            parse_mode="Markdown"
                        )
                    return CHATTING
                else:
                    await update.message.reply_text(
                        "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥."
                    )
                    return CHATTING
            
            # Send typing notification
            chat_stats[user_id].is_typing = True
            await context.bot.send_chat_action(
                chat_id=int(partner_id),
                action="typing"
            )
            
            # Handle different types of messages
            if update.message.text:
                # For text messages, use regular send_message
                await context.bot.send_message(
                    chat_id=int(partner_id),
                    text=update.message.text
                )
            elif update.message.voice:
                # For voice messages, download and send directly
                try:
                    # First, notify the partner that voice is being processed
                    await context.bot.send_chat_action(
                        chat_id=int(partner_id),
                        action="record_voice"
                    )
                    
                    # Log voice message details for debugging
                    voice_file_id = update.message.voice.file_id
                    voice_duration = update.message.voice.duration
                    logger.info(f"Processing voice message from {user_id} to {partner_id}: file_id={voice_file_id}, duration={voice_duration}s")
                    
                    # Get the voice file
                    voice_file = await context.bot.get_file(voice_file_id)
                    
                    # Download the voice file
                    voice_bytes = await voice_file.download_as_bytearray()
                    
                    # Send as a new voice message
                    sent = await context.bot.send_voice(
                        chat_id=int(partner_id),
                        voice=voice_bytes,
                        duration=voice_duration,
                        caption=update.message.caption if update.message.caption else None
                    )
                    
                    if sent:
                        logger.info(f"Successfully sent voice message from {user_id} to {partner_id}")
                    else:
                        logger.warning(f"Voice message send returned None, but no exception was raised")
                        
                except telegram.error.BadRequest as e:
                    logger.error(f"BadRequest error sending voice message: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ Telegram. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
                except telegram.error.Unauthorized as e:
                    logger.error(f"Unauthorized error sending voice message: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞."
                    )
                    # End the chat since the partner is unavailable
                    return await end_chat(update, context)
                except Exception as e:
                    logger.error(f"Error sending voice message: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è."
                    )
            elif update.message.video_note:
                # For video notes (circles), download and send directly
                try:
                    # First, notify the partner that video note is being processed
                    await context.bot.send_chat_action(
                        chat_id=int(partner_id),
                        action="record_video_note"
                    )
                    
                    # Get the video note file
                    video_note_file_id = update.message.video_note.file_id
                    video_note_length = update.message.video_note.length
                    video_note_duration = update.message.video_note.duration
                    
                    logger.info(f"Processing video note from {user_id} to {partner_id}: file_id={video_note_file_id}")
                    
                    # Get the file
                    video_note_file = await context.bot.get_file(video_note_file_id)
                    
                    # Download the file
                    video_note_bytes = await video_note_file.download_as_bytearray()
                    
                    # Send as a new video note
                    sent = await context.bot.send_video_note(
                        chat_id=int(partner_id),
                        video_note=video_note_bytes,
                        length=video_note_length,
                        duration=video_note_duration
                    )
                    
                    if sent:
                        logger.info(f"Successfully sent video note from {user_id} to {partner_id}")
                    
                except Exception as e:
                    logger.error(f"Error sending video note: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ-–∫—Ä—É–∂–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
            elif update.message.video:
                # For videos, download and send directly
                try:
                    # Get video details
                    video_file_id = update.message.video.file_id
                    video_duration = update.message.video.duration
                    video_width = update.message.video.width
                    video_height = update.message.video.height
                    caption = update.message.caption
                    
                    logger.info(f"Processing video from {user_id} to {partner_id}: file_id={video_file_id}")
                    
                    # Get the file
                    video_file = await context.bot.get_file(video_file_id)
                    
                    # Download the file
                    video_bytes = await video_file.download_as_bytearray()
                    
                    # Send as a new video
                    sent = await context.bot.send_video(
                        chat_id=int(partner_id),
                        video=video_bytes,
                        duration=video_duration,
                        width=video_width,
                        height=video_height,
                        caption=caption
                    )
                    
                    if sent:
                        logger.info(f"Successfully sent video from {user_id} to {partner_id}")
                    
                except Exception as e:
                    logger.error(f"Error sending video: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
            elif update.message.photo:
                # For photos, download and send directly
                try:
                    # Get the largest photo (best quality)
                    photo = update.message.photo[-1]
                    photo_file_id = photo.file_id
                    caption = update.message.caption
                    
                    logger.info(f"Processing photo from {user_id} to {partner_id}: file_id={photo_file_id}")
                    
                    # Get the file
                    photo_file = await context.bot.get_file(photo_file_id)
                    
                    # Download the file
                    photo_bytes = await photo_file.download_as_bytearray()
                    
                    # Send as a new photo
                    sent = await context.bot.send_photo(
                        chat_id=int(partner_id),
                        photo=photo_bytes,
                        caption=caption
                    )
                    
                    if sent:
                        logger.info(f"Successfully sent photo from {user_id} to {partner_id}")
                    
                except Exception as e:
                    logger.error(f"Error sending photo: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
            elif update.message.video:
                # For videos, use copy_message
                try:
                    await context.bot.copy_message(
                        chat_id=int(partner_id),
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
                    logger.debug(f"Copied video from {user_id} to {partner_id}")
                except Exception as e:
                    logger.error(f"Error copying video: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
            elif update.message.sticker or update.message.animation or update.message.document or update.message.audio:
                # For other media types, use copy_message
                try:
                    await context.bot.copy_message(
                        chat_id=int(partner_id),
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
                    logger.debug(f"Copied media from {user_id} to {partner_id}")
                except Exception as e:
                    logger.error(f"Error copying media: {e}", exc_info=True)
                    await update.message.reply_text(
                        "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ–¥–∏–∞-—Ñ–∞–π–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
                    )
            else:
                # Unsupported message type
                await update.message.reply_text(
                    "‚ö†Ô∏è –≠—Ç–æ—Ç —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è."
                )
            
            # Update typing status
            chat_stats[user_id].is_typing = False
            chat_stats[user_id].last_message_time = time.time()
            
            return CHATTING
            
        except Exception as e:
            logger.error(f"Error forwarding message: {e}", exc_info=True)
            
            # If we can't message the partner, end the chat
            if user_id in active_chats:
                del active_chats[user_id]
            if partner_id in active_chats:
                del active_chats[partner_id]
            
            keyboard = [
                [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
            ]
            
            await update.message.reply_text(
                text="‚ùå *–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–º*\n\n–ß–∞—Ç –∑–∞–≤–µ—Ä—à–µ–Ω.",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            return START
    else:
        # Not in chat, show main menu
        keyboard = [
            [
                InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile"),
                InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")
            ]
        ]
        
        # Check if message is a command
        if update.message.text and update.message.text.startswith('/'):
            if update.message.text.lower() == '/start':
                await update.message.reply_text(
                    f"*–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Dox: –ê–Ω–æ–Ω–∏–º–Ω—ã–π –ß–∞—Ç* üé≠\n\n"
                    f"–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –∞–Ω–æ–Ω–∏–º–Ω–æ –æ–±—â–∞—Ç—å—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏.\n\n"
                    f"*–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:*",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode="Markdown"
                )
                return START
            elif update.message.text.lower() == '/help':
                await update.message.reply_text(
                    "*–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*\n"
                    "/start - –ù–∞—á–∞—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞\n"
                    "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return START
        
        await update.message.reply_text(
            text="–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return START

async def end_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """End the current chat."""
    try:
        user_id = str(update.effective_user.id)
        
        # Check if user is in active chat
        if user_id not in active_chats:
            keyboard = [
                [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
                [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
            ]
            
            await update.effective_message.reply_text(
                text="‚ùå *–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞*",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            return START
        
        partner_id = active_chats[user_id]
        
        # Update chat statistics
        if user_id in chat_stats:
            stats = chat_stats[user_id]
            chat_duration = time.time() - stats.start_time
            
            # Update user data with chat statistics
            if user_id in user_data:
                user_data[user_id]["chat_count"] = user_data[user_id].get("chat_count", 0) + 1
                user_data[user_id]["total_chat_duration"] = user_data[user_id].get("total_chat_duration", 0) + chat_duration
                
                # Calculate average chat duration
                chat_count = user_data[user_id]["chat_count"]
                total_duration = user_data[user_id]["total_chat_duration"]
                user_data[user_id]["avg_chat_duration"] = total_duration / chat_count
                
                # Update active days
                today = datetime.now().strftime("%Y-%m-%d")
                active_days = user_data[user_id].get("active_days", [])
                if today not in active_days:
                    active_days.append(today)
                    # Keep only last 30 days
                    if len(active_days) > 30:
                        active_days = active_days[-30:]
                user_data[user_id]["active_days"] = active_days
                
                save_user_data(user_data)
            
            # Delete chat stats
            del chat_stats[user_id]
        
        # Unpin messages
        try:
            if "pinned_message_id" in context.user_data:
                await context.bot.unpin_chat_message(
                    chat_id=update.effective_chat.id,
                    message_id=context.user_data["pinned_message_id"]
                )
                del context.user_data["pinned_message_id"]
        except Exception as e:
            logger.error(f"Error unpinning message: {e}")
        
        # Clean up chat connection
        del active_chats[user_id]
        
        # Delete all messages in the chat (for the current user)
        try:
            # Send a message that will be used to clear the chat
            clear_message = await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="üßπ *–û—á–∏—Å—Ç–∫–∞ —á–∞—Ç–∞...*",
                parse_mode="Markdown"
            )
            
            # Delete all messages up to this one
            for i in range(clear_message.message_id - 1, 0, -1):
                try:
                    await context.bot.delete_message(
                        chat_id=update.effective_chat.id,
                        message_id=i
                    )
                except Exception:
                    # Ignore errors for messages that can't be deleted
                    pass
            
            # Delete the clear message itself
            await context.bot.delete_message(
                chat_id=update.effective_chat.id,
                message_id=clear_message.message_id
            )
        except Exception as e:
            logger.error(f"Error clearing chat messages: {e}")
        
        # Notify the user that chat has ended
        keyboard = [
            [InlineKeyboardButton("üîç –ù–∞–π—Ç–∏ –Ω–æ–≤–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞", callback_data="find_chat")],
            [InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data="profile")]
        ]
        
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="‚ùå *–ß–∞—Ç –∑–∞–≤–µ—Ä—à–µ–Ω*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        
        # Notify partner that chat has ended and update their stats
        if partner_id in active_chats:
            # Update partner's chat statistics
            if partner_id in chat_stats:
                partner_stats = chat_stats[partner_id]
                partner_chat_duration = time.time() - partner_stats.start_time
                
                # Update partner data with chat statistics
                if partner_id in user_data:
                    user_data[partner_id]["chat_count"] = user_data[partner_id].get("chat_count", 0) + 1
                    user_data[partner_id]["total_chat_duration"] = user_data[partner_id].get("total_chat_duration", 0) + partner_chat_duration
                    
                    # Calculate average chat duration
                    partner_chat_count = user_data[partner_id]["chat_count"]
                    partner_total_duration = user_data[partner_id]["total_chat_duration"]
                    user_data[partner_id]["avg_chat_duration"] = partner_total_duration / partner_chat_count
                    
                    # Update active days
                    today = datetime.now().strftime("%Y-%m-%d")
                    partner_active_days = user_data[partner_id].get("active_days", [])
                    if today not in partner_active_days:
                        partner_active_days.append(today)
                        # Keep only last 30 days
                        if len(partner_active_days) > 30:
                            partner_active_days = partner_active_days[-30:]
                    user_data[partner_id]["active_days"] = partner_active_days
                    
                    save_user_data(user_data)
                
                # Delete partner's chat stats
                del chat_stats[partner_id]
            
            # Unpin messages for partner
            try:
                if f"partner_{partner_id}_pinned_message" in context.user_data:
                    await context.bot.unpin_chat_message(
                        chat_id=int(partner_id),
                        message_id=context.user_data[f"partner_{partner_id}_pinned_message"]
                    )
                    del context.user_data[f"partner_{partner_id}_pinned_message"]
            except Exception as e:
                logger.error(f"Error unpinning partner's message: {e}")
            
            # Delete all messages in the chat (for the partner)
            try:
                # Send a message that will be used to clear the chat
                partner_clear_message = await context.bot.send_message(
                    chat_id=int(partner_id),
                    text="üßπ *–û—á–∏—Å—Ç–∫–∞ —á–∞—Ç–∞...*",
                    parse_mode="Markdown"
                )
                
                # Delete all messages up to this one
                for i in range(partner_clear_message.message_id - 1, 0, -1):
                    try:
                        await context.bot.delete_message(
                            chat_id=int(partner_id),
                            message_id=i
                        )
                    except Exception:
                        # Ignore errors for messages that can't be deleted
                        pass
                
                # Delete the clear message itself
                await context.bot.delete_message(
                    chat_id=int(partner_id),
                    message_id=partner_clear_message.message_id
                )
            except Exception as e:
                logger.error(f"Error clearing partner's chat messages: {e}")
            
            # Notify partner that chat has ended
            await context.bot.send_message(
                chat_id=int(partner_id),
                text="‚ùå *–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –∑–∞–≤–µ—Ä—à–∏–ª —á–∞—Ç*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
            
            # Clean up partner's chat connection
            del active_chats[partner_id]
        
        # Check for achievements
        await update_achievements(user_id, context)
        if partner_id in user_data:
            await update_achievements(partner_id, context)
        
        # Ask user to rate the partner
        rating_keyboard = []
        for i in range(1, 6):
            stars = "‚≠ê" * i
            rating_keyboard.append([InlineKeyboardButton(stars, callback_data=f"rate_{partner_id}_{i}")])
        
        rating_keyboard.append([InlineKeyboardButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_rating")])
        
        # Include chat statistics in rating request
        chat_duration_minutes = int(chat_duration / 60)
        message_count = user_data[user_id].get("total_messages", 0) - user_data[user_id].get("prev_total_messages", 0)
        user_data[user_id]["prev_total_messages"] = user_data[user_id].get("total_messages", 0)
        
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —á–∞—Ç–∞:*\n"
                 f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {chat_duration_minutes} –º–∏–Ω.\n"
                 f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–π: {message_count}\n\n"
                 f"–û—Ü–µ–Ω–∏—Ç–µ –≤–∞—à–µ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞:",
            reply_markup=InlineKeyboardMarkup(rating_keyboard),
            parse_mode="Markdown"
        )
        
        return START
        
    except Exception as e:
        logger.error(f"Error in end_chat: {e}", exc_info=True)
        return START

async def save_avatar(user_id: str, photo_file) -> str:
    """Save user's avatar photo."""
    try:
        os.makedirs("avatars", exist_ok=True)
        file_path = f"avatars/{user_id}.jpg"
        await photo_file.download_to_drive(file_path)
        return file_path
    except Exception as e:
        logger.error(f"Error saving avatar: {e}")
        return None

async def update_achievements(user_id: str, context: ContextTypes.DEFAULT_TYPE):
    """Update user achievements based on their stats."""
    user = user_data.get(user_id, {})
    achievements = user.get("achievements", [])
    chat_count = user.get("chat_count", 0)
    rating_5_count = user.get("rating_5_count", 0)
    active_days = user.get("active_days", 0)
    
    new_achievements = []
    
    if chat_count >= ACHIEVEMENTS["CHAT_MASTER"]["requirement"] and "CHAT_MASTER" not in achievements:
        new_achievements.append(ACHIEVEMENTS["CHAT_MASTER"])
        achievements.append("CHAT_MASTER")
    
    if rating_5_count >= ACHIEVEMENTS["POPULAR"]["requirement"] and "POPULAR" not in achievements:
        new_achievements.append(ACHIEVEMENTS["POPULAR"])
        achievements.append("POPULAR")
    
    if active_days >= ACHIEVEMENTS["ACTIVE"]["requirement"] and "ACTIVE" not in achievements:
        new_achievements.append(ACHIEVEMENTS["ACTIVE"])
        achievements.append("ACTIVE")
    
    if new_achievements:
        user_data[user_id]["achievements"] = achievements
        save_user_data(user_data)
        
        # Notify user about new achievements
        achievement_text = "*üèÜ –ù–æ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è!*\n\n"
        for achievement in new_achievements:
            achievement_text += f"{achievement['name']} - {achievement['description']}\n"
        
        try:
            await context.bot.send_message(
                chat_id=int(user_id),
                text=achievement_text,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Error sending achievement notification: {e}")

def main() -> None:
    """Start the bot."""
    try:
        logger.info("Starting bot...")
        # Create the Application
        token = "8039344227:AAEDCP_902a3r52JIdM9REqUyPx-p2IVtxA"
        logger.info("Using token: %s", token)
        
        # Build application
        application = (
            Application.builder()
            .token(token)
            .build()
        )
        
        # Add conversation handler
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("start", start)],
            states={
                START: [
                    CallbackQueryHandler(button_handler),
                    MessageHandler(filters.ALL & ~filters.COMMAND, handle_message)
                ],
                CHATTING: [
                    CallbackQueryHandler(button_handler),
                    CommandHandler("end", end_chat),
                    MessageHandler(filters.ALL & ~filters.COMMAND, handle_message)
                ],
                PROFILE: [
                    CallbackQueryHandler(button_handler),
                    MessageHandler(filters.ALL & ~filters.COMMAND, handle_message)
                ],
                EDIT_PROFILE: [
                    CallbackQueryHandler(button_handler),
                    MessageHandler(filters.ALL & ~filters.COMMAND, handle_message)
                ]
            },
            fallbacks=[CommandHandler("start", start)]
        )
        
        application.add_handler(conv_handler)
        
        # Add error handler
        application.add_error_handler(error_handler)
        
        # Get environment variables for Railway
        PORT = int(os.environ.get('PORT', '8443'))
        RAILWAY_STATIC_URL = os.environ.get('RAILWAY_STATIC_URL', 'dox-production.up.railway.app')
        
        # Start the Bot with webhook if on Railway, otherwise use polling
        if 'RAILWAY_STATIC_URL' in os.environ:
            logger.info(f"Starting webhook on {RAILWAY_STATIC_URL}")
            application.run_webhook(
                listen="0.0.0.0",
                port=PORT,
                url_path=token,
                webhook_url=f"https://{RAILWAY_STATIC_URL}/{token}"
            )
        else:
            logger.info("Starting polling...")
            application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)
        
        logger.info("Bot stopped")
    except Exception as e:
        logger.critical("Fatal error starting bot: %s", str(e), exc_info=True)
        sys.exit(1)

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle errors in the dispatcher."""
    logger.error("Exception while handling an update:", exc_info=context.error)
    
    # Send message to the user
    if update and isinstance(update, Update) and update.effective_message:
        await update.effective_message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )

if __name__ == "__main__":
    main() 